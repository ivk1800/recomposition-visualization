<resources>
    <string name="avoid_unnecessary_state_reads_bad_explanation">Здесь angle пробрасывается через цепочку Function1 -> Function2 -> Function3 -> RedBox.
Каждая функция принимает angle как параметр и будет рекомпозирована при каждом изменении значения. Function1, Function2 и Function3 сами по себе ничего не делают с angle, кроме как просто передают его дальше. Но поскольку angle является параметром, Compose считает их зависящими от состояния и выполняет рекомпозицию.</string>
    <string name="avoid_unnecessary_state_reads_1_good_explanation">Теперь Function1, Function2 и Function3 не зависят от конкретного значения angle, а получают объект State&lt;Float&gt;.
Поскольку State это стабильный тип, Compose видит, что ссылка на объект не меняется при обновлении angle.value.
Рекомпозиция происходит только там, где реально читается angle.value, то есть в RedBox.
Таким образом, лишние рекомпозиций промежуточных функций исчезают.</string>
    <string name="avoid_unnecessary_state_reads_2_good_explanation">Теперь Function1, Function2 и Function3 получают лямбду () -> Float, а не конкретное значение angle.
Поскольку сама лямбда стабильна и не меняется при обновлении состояния, Compose видит, что ссылка на объект не меняется, и рекомпозиция происходит только там, где вызывается angle.invoke() то есть в RedBox.
Таким образом, лишние рекомпозиций промежуточных функций исчезают.</string>
    <string name="not_lambda_modifiers_bad_explanation">В этом коде проблема в том, что модификаторы (.rotate(angle) и др.) строятся внутри @Composable функции и напрямую зависят от изменяемого состояния (angle).
Когда angle меняется, Compose считает, что весь Modifier-цепочка изменилась и пересоздаёт её полностью. Это приводит к лишним рекомпозициям.</string>
    <string name="lambda_modifiers_good_explanation">В этом коде модификатор graphicsLayer принимает лямбду. Она является стабильной и не пересоздаётся при изменении состояния, поэтому сам модификатор остаётся тем же объектом. При изменении angle Compose просто повторно вызывает лямбду уже на фазе отрисовки, обновляя свойство rotationZ.
Таким образом, вместо пересоздания всей цепочки модификаторов при каждом изменении состояния, если использовать .rotate(angle), меняется только параметр и происходит отрисока, что делает обновление более эффективным.</string>
    <string name="read_state_bad_explanation">Переменная count считывается внутри Column { ... }, то есть при каждой отрисовки Column будет заново читать countState.value. Это приводит к тому, что при изменении countState происходит рекомпозиция всей колонки, даже если значение используется только в одном месте — внутри content.
Иначе говоря: чтение состояния вынесено слишком "высоко". Из-за этого больше компонентов подписаны на изменения, чем реально нужно.</string>
    <string name="read_state_good_explanation">Состояние countState читается ровно там, где оно нужно — внутри content. Благодаря этому на изменения значения будет реагировать только content, а не вся Column.
То есть область подписки на состояние сузилась, и теперь при обновлении countState перерисовывается только та часть UI, которая действительно зависит от него.</string>
    <string name="unstable_type_explanation">MyData — это data class без аннотации @Stable. В Compose такие классы считаются нестабильными (unstable), даже если внутри у них "простые" поля. Из-за этого каждый раз при recomposition (триггерится изменением count.value) RedBox будет пересоздавать MyData(listOf("test")).
Более того, List&lt;String&gt; сам по себе нестабилен (нет гарантий, что он не поменяется). Поэтому MyData ещё и наследует эту нестабильность.
В итоге Compose не может оптимизировать проверку и всегда будет перерисовывать RedBox, даже если данные фактически не изменились.</string>
    <string name="immutable_type_explanation">@Immutable явно сообщает Compose, что экземпляр MyData не изменяемый: его поля не меняются после создания, значит, при одинаковых аргументах объект можно считать «эквивалентным». Благодаря этому компилятор и runtime Compose могут пропускать лишние рекомпозиции: если новый MyData равен старому, RedBox не будет перерисован. Даже несмотря на то, что List&lt;String&gt; сам по себе нестабилен, аннотация @Immutable говорит: «раз объект immutable и мы не меняем список внутри, считай это безопасным». Это снимает лишние recomposition-триггеры.
Теперь RedBox действительно будет перерисовываться только тогда, когда данные реально изменятся.</string>
    <string name="movable_content_of_explanation">movableContentOf создаёт Composable, который может перемещаться между разными местами дерева композиции, сохраняя своё состояние. При перемещении контента из Column в Row (или наоборот) не происходит лишних рекомпозиций для внутреннего содержимого RedBox и GreenBox. Их состояние сохраняется, и Compose не пересоздаёт эти компоненты.</string>
    <string name="launch_effect_key_bad_explanation">В Compose ключ определяет когда эффект должен перезапуститься. Каждый раз, когда count.value меняется, Compose считает, что если ключ изменился, полностью пересоздаёт LaunchedEffect Даже если внутри эффект делает что-то простое (как здесь — println), эффект запускается заново, что в реальных приложениях может быть дорогостоящим.
LaunchedEffect предназначен для запуска действий один раз или при реальных изменениях зависимостей, а не каждый раз, когда изменяется простое значение состояния. Здесь мы логируем значение — это не требует перезапуска эффекта, достаточно просто читать значение внутри блока.
Использовать простое состояние в качестве ключа без необходимости плохая практика, потому что это приводит к лишним recomposition и перезапуску эффектов.</string>
    <string name="launch_effect_key_good_explanation">В качестве ключа используется сам объект count, а не его значение count.value. LaunchedEffect запускается один раз при создании EntryPoint и не пересоздаётся при каждом изменении значения. Для отслеживания изменений значения используется snapshotFlow { count.value }, который создаёт поток изменений состояния. Внутри collect выполняется логирование только тогда, когда count.value действительно изменяется. Compose не пересоздаёт весь эффект и не тратит лишние ресурсы на повторные запуски.</string>
    <string name="lazy_list_with_key_good_explanation">Создаётся LazyColumn с items, для каждого элемента используется ключ key = { index -> items[index].id }. Это гарантирует, что Compose сопоставляет Composable с конкретным элементом по id, а не по позиции в списке. Внутри LazyColumn элементы делятся на Even и Odd, и каждый использует remember для сохранения времени создания (time).
Если бы ключи не использовались, при добавлении нового элемента в начало списка Compose не смог бы понять, что старые элементы просто сдвинулись вниз. Все элементы пересоздавались бы заново, time обновлялся бы у всех элементов, хотя фактически они не изменились. Именно поэтому использование ключа items[index].id критично для оптимизации.
Благодаря этому только новые или изменённые элементы рекомпозируются. Остальные элементы это никак не затрагивает, что экономит ресурсы при больших списках.</string>
    <string name="lazy_list_without_key_bad_explanation">В этом примере LazyColumn рендерит элементы списка без ключей, сопоставляя Composable по позиции (index). При добавлении нового элемента в начало все элементы сдвигаются вниз, и Compose считает, что на каждой позиции теперь новый элемент. В результате все Composable пересоздаются. Это четко видно, что при добавлении нового элемента рекомопозируются Odd и Even, даже если данные элементов фактически не изменились.</string>
    <string name="derived_state_of_explanation">В этом примере используется derivedStateOf, чтобы вычислять цвет фона на основе позиции скролла LazyColumn. Вместо того чтобы пересчитывать цвет при каждой мелкой прокрутке и вызывать ненужные рекомпозиции, Compose обновляет состояние только тогда, когда реально изменяется условие (firstVisibleItemIndex > 0). Это уменьшает количество лишних пересчётов и делает код эффективнее.</string>
    <string name="derived_state_of_bad_explanation">Так как напрямую используется state.firstVisibleItemIndex в условии, то каждое малейшее движение списка (например, скролл на пару пикселей, даже без смены элемента) приводит к новой рекомпозиции всего Box, хотя по факту цвет остаётся тем же самым. Это значит, что мы нагружаем систему лишними вычислениями и перерисовками, которые вообще не дают пользователю никакого видимого эффекта.
По сути, здесь Compose реагирует на любое изменение LazyListState, а не на логическое условие «элемент стал больше нуля или нет». Поэтому вместо оптимизированных апдейтов у нас идёт поток бессмысленных рекомпозиций.</string>

</resources>
